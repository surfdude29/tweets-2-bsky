import { parse as devalueParse } from 'devalue';
function normalizeBaseUrl(value) {
    const trimmed = value.trim();
    if (!trimmed)
        return 'https://sweetistics.com';
    return trimmed.endsWith('/') ? trimmed.slice(0, -1) : trimmed;
}
export class SweetisticsClient {
    baseUrl;
    apiKey;
    userAgent;
    timeoutMs;
    // Prevent hanging requests; keep Sweetistics calls snappy for CLI users.
    static DEFAULT_REQUEST_TIMEOUT_MS = 15_000;
    constructor(options) {
        this.baseUrl = normalizeBaseUrl(options.baseUrl);
        this.apiKey = options.apiKey.trim();
        this.userAgent = options.userAgent;
        this.timeoutMs = options.timeoutMs ?? SweetisticsClient.DEFAULT_REQUEST_TIMEOUT_MS;
        if (!this.apiKey) {
            throw new Error('Sweetistics API key is required');
        }
    }
    async tweet(text, replyToTweetId, mediaIds) {
        const payload = { text };
        if (replyToTweetId) {
            payload.replyToTweetId = replyToTweetId;
        }
        if (mediaIds && mediaIds.length > 0) {
            payload.mediaIds = mediaIds;
        }
        let response;
        try {
            response = await this.fetchWithTimeout(`${this.baseUrl}/api/actions/tweet`, {
                method: 'POST',
                headers: {
                    authorization: `Bearer ${this.apiKey}`,
                    'content-type': 'application/json',
                    ...(this.userAgent ? { 'user-agent': this.userAgent } : {}),
                },
                body: JSON.stringify(payload),
            });
        }
        catch (error) {
            return { success: false, error: this.normalizeError(error) };
        }
        let data;
        try {
            data = await response.json();
        }
        catch (error) {
            return {
                success: false,
                error: `Sweetistics response parse failed: ${error instanceof Error ? error.message : String(error)}`,
            };
        }
        const success = typeof data?.success === 'boolean' ? data.success : false;
        const tweetId = typeof data?.tweetId === 'string' ? data.tweetId : undefined;
        const errorMessage = typeof data?.error === 'string' ? data.error : undefined;
        if (!response.ok || !success) {
            const reason = errorMessage || `HTTP ${response.status}`;
            return { success: false, error: reason };
        }
        return { success: true, tweetId };
    }
    async read(tweetId) {
        // Public REST route that returns a single tweet record
        const url = `${this.baseUrl}/api/tweets/${encodeURIComponent(tweetId)}`;
        let response;
        try {
            response = await this.fetchWithTimeout(url, {
                headers: {
                    authorization: `Bearer ${this.apiKey}`,
                    ...(this.userAgent ? { 'user-agent': this.userAgent } : {}),
                },
            });
        }
        catch (error) {
            return { success: false, error: this.normalizeError(error) };
        }
        if (!response.ok) {
            return { success: false, error: `HTTP ${response.status}` };
        }
        // biome-ignore lint/suspicious/noExplicitAny: Sweetistics responses are loosely typed
        let data;
        try {
            data = await response.json();
        }
        catch (error) {
            return {
                success: false,
                error: `Sweetistics response parse failed: ${error instanceof Error ? error.message : String(error)}`,
            };
        }
        if (!data?.id || !data?.author) {
            return { success: false, error: 'Malformed tweet payload from Sweetistics' };
        }
        const tweet = {
            id: String(data.id),
            text: String(data.text ?? ''),
            author: {
                username: String(data.author.username ?? ''),
                name: String(data.author.name ?? ''),
            },
            createdAt: data.createdAt,
            replyCount: data.metrics?.replyCount,
            retweetCount: data.metrics?.retweetCount,
            likeCount: data.metrics?.likeCount,
            conversationId: data.conversationId,
            // biome-ignore lint/suspicious/noExplicitAny: Sweetistics responses are loosely typed
            inReplyToStatusId: data.referencedTweets?.find?.((r) => r?.type === 'replied_to')?.id,
        };
        return { success: true, tweet };
    }
    async replies(tweetId) {
        return this.fetchConversation(tweetId, { excludeRoot: true });
    }
    async thread(tweetId) {
        return this.fetchConversation(tweetId, { excludeRoot: false });
    }
    async search(query, count) {
        const payload = {
            query,
            capabilities: [
                {
                    resource: 'tweets',
                    source: 'postgres',
                    limit: Math.max(1, Math.min(count, 50)),
                    offset: 0,
                    detail: 'summary',
                    includeRetweets: true,
                },
            ],
        };
        let response;
        try {
            response = await this.fetchWithTimeout(`${this.baseUrl}/api/trpc/search.execute?batch=1`, {
                method: 'POST',
                headers: {
                    authorization: `Bearer ${this.apiKey}`,
                    'content-type': 'application/json',
                    ...(this.userAgent ? { 'user-agent': this.userAgent } : {}),
                },
                body: JSON.stringify({ 0: { json: payload } }),
            });
        }
        catch (error) {
            return { success: false, error: this.normalizeError(error) };
        }
        if (!response.ok) {
            return { success: false, error: `HTTP ${response.status}` };
        }
        // biome-ignore lint/suspicious/noExplicitAny: Sweetistics responses are loosely typed
        let body;
        try {
            body = await response.json();
        }
        catch (error) {
            return {
                success: false,
                error: `Sweetistics response parse failed: ${error instanceof Error ? error.message : String(error)}`,
            };
        }
        const envelope = Array.isArray(body) ? body[0] : body;
        if (envelope?.error) {
            const message = envelope.error?.message ?? 'Unknown search error';
            return { success: false, error: message };
        }
        const dataField = envelope?.result?.data;
        if (!dataField) {
            return { success: false, error: 'Missing data in Sweetistics search response' };
        }
        // biome-ignore lint/suspicious/noExplicitAny: Sweetistics responses are loosely typed
        let parsed;
        try {
            parsed = typeof dataField === 'string' ? devalueParse(dataField) : dataField;
        }
        catch (error) {
            return {
                success: false,
                error: `Sweetistics search decode failed: ${error instanceof Error ? error.message : String(error)}`,
            };
        }
        const tweetsSection = parsed?.tweets;
        // biome-ignore lint/suspicious/noExplicitAny: Sweetistics responses are loosely typed
        const items = tweetsSection?.items ?? [];
        if (items.length === 0) {
            return { success: true, tweets: [] };
        }
        const tweets = items.map((item) => {
            const authorUsername = item.authorUsername || item.username || item.full?.author?.username || '';
            const authorName = item.authorName || item.full?.author?.name || authorUsername;
            const createdAt = typeof item.createdAt === 'string'
                ? item.createdAt
                : (item.createdAt?.toString?.() ??
                    (Array.isArray(item.createdAt) && item.createdAt[0] === 'Date' ? item.createdAt[1] : undefined));
            const metrics = item.full?.metrics ?? item.full ?? item;
            return {
                id: String(item.id),
                text: String(item.text ?? item.full?.text ?? ''),
                author: { username: String(authorUsername), name: String(authorName) },
                createdAt,
                replyCount: metrics?.replyCount ?? metrics?.replies ?? 0,
                retweetCount: metrics?.retweetCount ?? metrics?.retweets ?? 0,
                likeCount: metrics?.likeCount ?? metrics?.likes ?? 0,
                conversationId: item.conversationId ?? item.full?.conversationId,
                inReplyToStatusId: item.full?.inReplyToStatusId ?? undefined,
            };
        });
        return { success: true, tweets };
    }
    async getCurrentUser() {
        const headers = {
            authorization: `Bearer ${this.apiKey}`,
            'content-type': 'application/json',
            ...(this.userAgent ? { 'user-agent': this.userAgent } : {}),
        };
        let response;
        try {
            response = await this.fetchWithTimeout(`${this.baseUrl}/api/trpc/user.getCurrent?batch=1`, {
                method: 'POST',
                headers,
                body: JSON.stringify({ 0: { json: null } }),
            });
        }
        catch (error) {
            return { success: false, error: this.normalizeError(error) };
        }
        // Some deployments only allow GET for queries; fall back if POST is not allowed
        if (response.status === 405) {
            try {
                response = await this.fetchWithTimeout(`${this.baseUrl}/api/trpc/user.getCurrent?input=${encodeURIComponent('null')}`, {
                    method: 'GET',
                    headers,
                });
            }
            catch (error) {
                return { success: false, error: this.normalizeError(error) };
            }
        }
        if (!response.ok) {
            return { success: false, error: `HTTP ${response.status}` };
        }
        // biome-ignore lint/suspicious/noExplicitAny: Sweetistics responses are loosely typed
        let body;
        try {
            body = await response.json();
        }
        catch (error) {
            return {
                success: false,
                error: `Sweetistics response parse failed: ${error instanceof Error ? error.message : String(error)}`,
            };
        }
        const envelope = Array.isArray(body) ? body[0] : body;
        const maybeError = envelope?.error?.message || envelope?.result?.error?.message;
        if (maybeError) {
            return { success: false, error: String(maybeError) };
        }
        let data = envelope?.result?.data?.json ?? envelope?.result?.data ?? envelope?.json ?? envelope;
        try {
            if (typeof data === 'string') {
                data = devalueParse(data);
            }
            else if (data && typeof data === 'object' && 'json' in data) {
                const inner = data.json;
                data = typeof inner === 'string' ? devalueParse(inner) : inner;
            }
        }
        catch (error) {
            return {
                success: false,
                error: `Sweetistics response decode failed: ${error instanceof Error ? error.message : String(error)}`,
            };
        }
        const user = data && typeof data === 'object' ? data : null;
        // biome-ignore lint/suspicious/noExplicitAny: Sweetistics responses are loosely typed
        if (!user || typeof user.id !== 'string') {
            return { success: false, error: 'Malformed user payload from Sweetistics' };
        }
        return {
            success: true,
            user: {
                // biome-ignore lint/suspicious/noExplicitAny: Sweetistics responses are loosely typed
                id: String(user.id),
                username: 
                // biome-ignore lint/suspicious/noExplicitAny: Sweetistics responses are loosely typed
                user.username ?? user.twitterUsername ?? null,
                // biome-ignore lint/suspicious/noExplicitAny: Sweetistics responses are loosely typed
                name: user.name ?? null,
                // biome-ignore lint/suspicious/noExplicitAny: Sweetistics responses are loosely typed
                email: user.email ?? null,
                // biome-ignore lint/suspicious/noExplicitAny: Sweetistics responses are loosely typed
                profileImageUrl: user.profileImageUrl ?? null,
            },
        };
    }
    async fetchConversation(tweetId, options = { excludeRoot: false, force: true }) {
        const url = new URL(`${this.baseUrl}/api/trpc/tweets.getConversation`);
        const input = { tweetId };
        // Always request a fresh conversation to avoid cached Sweetistics data unless explicitly disabled
        if (options.force ?? true) {
            input.force = 'true';
        }
        url.searchParams.set('input', JSON.stringify(input));
        let response;
        try {
            response = await this.fetchWithTimeout(url.toString(), {
                headers: {
                    authorization: `Bearer ${this.apiKey}`,
                    ...(this.userAgent ? { 'user-agent': this.userAgent } : {}),
                },
            });
        }
        catch (error) {
            return { success: false, error: this.normalizeError(error) };
        }
        if (!response.ok) {
            return { success: false, error: `HTTP ${response.status}` };
        }
        let envelope;
        try {
            envelope = (await response.json());
        }
        catch (error) {
            return {
                success: false,
                error: `Sweetistics response parse failed: ${error instanceof Error ? error.message : String(error)}`,
            };
        }
        if (!envelope?.result?.data) {
            return { success: false, error: 'Missing data in Sweetistics response' };
        }
        // biome-ignore lint/suspicious/noExplicitAny: Sweetistics responses are loosely typed
        let parsed;
        try {
            const raw = typeof envelope.result.data === 'string' ? devalueParse(envelope.result.data) : envelope.result.data;
            parsed = raw;
        }
        catch (error) {
            return {
                success: false,
                error: `Sweetistics response decode failed: ${error instanceof Error ? error.message : String(error)}`,
            };
        }
        const tweetIds = Array.isArray(parsed?.tweetIds) ? parsed.tweetIds.map(String) : [];
        // biome-ignore lint/suspicious/noExplicitAny: Sweetistics responses are loosely typed
        const tweetsMap = parsed?.tweets ?? {};
        if (tweetIds.length === 0 || Object.keys(tweetsMap).length === 0) {
            return { success: false, error: 'Conversation empty or unavailable' };
        }
        const rootId = tweetId;
        const filteredIds = options.excludeRoot ? tweetIds.filter((id) => id !== rootId) : tweetIds;
        const tweets = filteredIds
            .map((id) => tweetsMap[id])
            .filter(Boolean)
            // biome-ignore lint/suspicious/noExplicitAny: Sweetistics responses are loosely typed
            .map((item) => ({
            id: String(item.id),
            text: String(item.text ?? ''),
            author: {
                username: String(item.author?.username ?? ''),
                name: String(item.author?.name ?? ''),
            },
            createdAt: item.createdAt ?? item.timestamp ?? undefined,
            replyCount: item.replyCount ?? item.metrics?.replyCount,
            retweetCount: item.retweetCount ?? item.metrics?.retweetCount,
            likeCount: item.likeCount ?? item.metrics?.likeCount,
            conversationId: item.conversationId ?? undefined,
            inReplyToStatusId: item.inReplyToStatusId ?? undefined,
        }));
        return { success: true, tweets };
    }
    async uploadMedia(input) {
        try {
            const response = await this.fetchWithTimeout(`${this.baseUrl}/api/actions/media/upload`, {
                method: 'POST',
                headers: {
                    authorization: `Bearer ${this.apiKey}`,
                    'content-type': 'application/json',
                    ...(this.userAgent ? { 'user-agent': this.userAgent } : {}),
                },
                body: JSON.stringify(input),
            });
            let body;
            try {
                body = await response.json();
            }
            catch (error) {
                return { success: false, error: this.normalizeError(error) };
            }
            const mediaId = typeof body?.mediaId === 'string'
                ? body.mediaId
                : undefined;
            const errorMessage = typeof body?.error === 'string' ? body.error : undefined;
            const errorCode = typeof body?.code === 'string' ? body.code : undefined;
            if (!response.ok || !mediaId) {
                const details = [errorCode, errorMessage].filter(Boolean).join(': ');
                return { success: false, error: details.length > 0 ? details : `HTTP ${response.status}` };
            }
            return { success: true, mediaId };
        }
        catch (error) {
            return { success: false, error: this.normalizeError(error) };
        }
    }
    async fetchWithTimeout(url, init) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(new Error(`Request timed out after ${this.timeoutMs}ms`)), this.timeoutMs);
        try {
            return await fetch(url, { ...init, signal: controller.signal });
        }
        finally {
            clearTimeout(timeoutId);
        }
    }
    normalizeError(error) {
        if (error instanceof Error) {
            if (error.name === 'AbortError') {
                return 'Request timed out';
            }
            return error.message;
        }
        return String(error);
    }
}
//# sourceMappingURL=sweetistics-client.js.map